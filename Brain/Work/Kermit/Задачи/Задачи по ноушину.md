# KER-1064 "Duplicates"

Добавил в запрос Distinct ON (a.id) чтобы точно убрать дубли айдишок, по идее место роботы больше не должно дублироваться

```
WITH matched_ankets AS (  
  SELECT DISTINCT ON (a.id) a.id,  
         a.gender,  
         a.yearofbirth,  
         a.monthofbirth,  
         a.dayofbirth,  
         ROUND((  
          CASE WHEN job.info ILIKE '%' || 'Лингва' || '%' THEN 1 ELSE 0 END  
  
         )::float / 1 * 100) AS matching  
  FROM anket a  
  
  
  JOIN jobhistory job ON a.id = job.matureanket_id  
  WHERE job.info ILIKE '%' || 'Лингва' || '%'  
  
  
  GROUP BY a.id, a.gender, a.yearofbirth, a.monthofbirth, a.dayofbirth, job.info  
  HAVING (  
          CASE WHEN job.info ILIKE '%' || 'Лингва' || '%' THEN 1 ELSE 0 END  
  
         )::float / 1 * 100 >= 90  
         AND (  
          CASE WHEN job.info ILIKE '%' || 'Лингва' || '%' THEN 1 ELSE 0 END  
  
         )::float / 1 * 100 <= 100  
  
)  
SELECT ARRAY_AGG(ARRAY[id::bigint, matching::integer] ORDER BY matching DESC) as ankets FROM matched_ankets;
```

# KER-1204 "сделать графу Являлся владельцем авто - если поискомый не актуальный владелец @BUGS and Requests in Slack"

**Todo**: При отдаче деталок нужно отправлять отдельно для каждой машины актуальных владельцев, это графа является владельцем и являлся владельцем, это все остальные у которых isActual = false

Метод **getAnketDetailById** тут получение деталок двух типов

Являлся владельцем есть в: Деталке юзера **ТОЛЬКО**

**Является владельцем машин:** 
**Являлся владельцем:** Если в carOwnersWithCorrectDob[i].allOwners нет искомого человека указанyого как актуальный


# KER-1053 "Прогесс-бары для поиска @Прогресс-бары"

**Принцип роботы:**

При инициализации юзера, создается коннект с сокетом, он сохраняется локально на сервере прокси, сокет привязвается к айди сессии.

**Важно работать именно с айди сессии при мерже. Чтобы найти правильный сокет**

При мерже перед  стартом мержа отправляется эмит на прокси что начат мерж по таким то источникам:

`this.notificationsService.sendNotification(`  
  `'14',`  
  `NotificationTypeEnum.startMergeByAvailableSources,`  
  `{`  
    `sources: body.availableSources.map((i) => i.name),`  
  `},`  
`);`

На прокси нужно сдать sourceNameId - чтобы Артур понимал как показывать это

**В результате при мерже нужно:**
1. Что бы фронт понимал в какой базе уже начался мерж
2. В какой базе он закончился и сколько времени это заняло


**Реализация**
- При начале мержа шлем один эвент о том что начат мерж по таким то источникам, внутри sourceNameId
- После завершения поиска по источнику идет эвент со временем поиска и sourceNameId. Благодаря этому Артур сможет сделать прогрес бар по количеству источников с процентом выполнения

**Что нужно учесть: **
- Что будет если юзер закроет страницу?
- Как будет работать когда пойдет запрос через телеграмм бота?
- **!!!!** Уточнить у Димы как будет поднят сокет сервер и открыт порт к нему?
- Сокеты будут пропадать после перезагрузки. Нужно подумать за мехнизм реконекта или использовать Редис


**Как работать с фронта:**
1. Подключится к серверу сокета: 
```
const socket = io('http://localhost:3000', { extraHeaders: { Authorization: 'Bearer your-jwt-token' } });
```

2. Настроить обработку эвентов
 Количество найденных анкет лучше не показывать, так как из-за фильтра может отличатся число. Я пока его возвращаю пока для дебага
 

**Эвенты:**

```
export enum NotificationTypeEnum {  
  'startMergeByAvailableSources' = 'startMergeByAvailableSources',  
  'completeMergeByOneSource' = 'completeMergeByOneSource',  
  'mergeComplete' = 'mergeComplete',  
}
```

**Нотифы для поиска**

**Как работают**:
При запуске поиска в серче идет нотиф что он начался, в методе выполнения при каждом завершении этапа поиска идет эмит на ауз в котором будет айди поиска, и база в которой завештлся, там будет сколько результатов и за какое время, его нужно сохранить в поле searchHistory, и отдавать его на фронт, он сможет его просмотреть в любой момент, чтобы это было в риалтайме нужно этот этап также обновлять *Возможно и не нужно будет эвент слать* так как Фронт обновляет каждый раз историю.
При завершении поиска, нужно прислать эмит на фронт что *поиск Имя завершен, найдено н результатов*

**План:**
1. Слать эвенты из серча при поиске
2. Добавить столбец в бд ауза
3. Проверить что все работает при поиске по фото (Подключится к Дев ребиту)
4. Проверить что работает

В таблицу добавляю столбец этапы поиска - это джсон, обновлять каждый раз когда завершается этап. В истории всей отдавать это поле на фронт чтобы артур показывал, По сути он сможет видеть в риалтайме что и где искалось так как оно будет обновлятся и + будут приходить эвенты. **Эта штука будет работать только на общей истории**. **Также не будет работать на сирене.**

**Сложности:**
Отследить время поиска по фото - Написал Назарбеку чтобы он слал мне время в ответе

**Проблемы с Фронтом**
У Артура проблемы с подключением, нужно убедится что все работает локально, а именно:
- При старте мержа приходят эвенты старта и для каждого источника и что приходит полный массив источников
- Поресерчить механизм реконекта
*Тест 1*
В логах прокси получил для отправки в сессию юзера 45 источников при старте мержа

*Тест фронта*
Фронт не устанавливает коннект
![[Pasted image 20240718022049.png]]